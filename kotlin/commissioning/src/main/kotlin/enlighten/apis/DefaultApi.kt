/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package enlighten.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import enlighten.models.ClientError
import enlighten.models.ConflictError
import enlighten.models.ConnectionType
import enlighten.models.ConsumptionLifetimeResponse
import enlighten.models.ConsumptionStatsResponse
import enlighten.models.EnergyLifetimeResponse
import enlighten.models.EnvoysResponse
import enlighten.models.InventoryResponse
import enlighten.models.InvertersSummaryByEnvoyOrSiteResponse
import enlighten.models.MonthlyProductionResponse
import enlighten.models.NotFoundError
import enlighten.models.ProductionMeterReadingsResponse
import enlighten.models.RgmStatsResponse
import enlighten.models.SearchSystemIdResponse
import enlighten.models.ServerError
import enlighten.models.StatsResponse
import enlighten.models.Status
import enlighten.models.SummaryResponse
import enlighten.models.SystemsResponse
import enlighten.models.UnprocessableEntityError

import com.squareup.moshi.Json

import enlighten.infrastructure.ApiClient
import enlighten.infrastructure.ApiResponse
import enlighten.infrastructure.ClientException
import enlighten.infrastructure.ClientError
import enlighten.infrastructure.ServerException
import enlighten.infrastructure.ServerError
import enlighten.infrastructure.MultiValueMap
import enlighten.infrastructure.PartConfig
import enlighten.infrastructure.RequestConfig
import enlighten.infrastructure.RequestMethod
import enlighten.infrastructure.ResponseType
import enlighten.infrastructure.Success
import enlighten.infrastructure.toMultiValue

class DefaultApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.enphaseenergy.com/api/v2")
        }
    }

    /**
     * 
     * Returns a time series of energy consumption as measured by the consumption meter installed on the specified system. All measurements are in Watt-hours. If the system does not have a meter, returns &#x60;204&#x60; - No Content. If you don&#39;t have permission to view consumption data, the response code is &#x60;401&#x60;.  The time series includes one entry for each day from the &#x60;start_date&#x60; to the &#x60;end_date&#x60;. There are no gaps in the time series. If the response includes trailing zeroes, such as [909, 4970, 0, 0, 0], then no data has been reported for the last days in the series. You can check the system&#39;s status in the &#x60;meta&#x60; attribute of the response to determine when the system last reported and whether it has communication or metering problems.
     * @param systemId 
     * @param userId 
     * @param startDate The date on which to start the time series. Defaults to the system&#39;s operational date. (optional)
     * @param endDate The last date to include in the time series. Defaults to yesterday or the last day the system reported, whichever is earlier. (optional)
     * @return ConsumptionLifetimeResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun consumptionLifetime(systemId: kotlin.Int, userId: kotlin.String, startDate: java.time.LocalDate? = null, endDate: java.time.LocalDate? = null) : ConsumptionLifetimeResponse {
        val localVarResponse = consumptionLifetimeWithHttpInfo(systemId = systemId, userId = userId, startDate = startDate, endDate = endDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConsumptionLifetimeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Returns a time series of energy consumption as measured by the consumption meter installed on the specified system. All measurements are in Watt-hours. If the system does not have a meter, returns &#x60;204&#x60; - No Content. If you don&#39;t have permission to view consumption data, the response code is &#x60;401&#x60;.  The time series includes one entry for each day from the &#x60;start_date&#x60; to the &#x60;end_date&#x60;. There are no gaps in the time series. If the response includes trailing zeroes, such as [909, 4970, 0, 0, 0], then no data has been reported for the last days in the series. You can check the system&#39;s status in the &#x60;meta&#x60; attribute of the response to determine when the system last reported and whether it has communication or metering problems.
     * @param systemId 
     * @param userId 
     * @param startDate The date on which to start the time series. Defaults to the system&#39;s operational date. (optional)
     * @param endDate The last date to include in the time series. Defaults to yesterday or the last day the system reported, whichever is earlier. (optional)
     * @return ApiResponse<ConsumptionLifetimeResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun consumptionLifetimeWithHttpInfo(systemId: kotlin.Int, userId: kotlin.String, startDate: java.time.LocalDate?, endDate: java.time.LocalDate?) : ApiResponse<ConsumptionLifetimeResponse?> {
        val localVariableConfig = consumptionLifetimeRequestConfig(systemId = systemId, userId = userId, startDate = startDate, endDate = endDate)

        return request<Unit, ConsumptionLifetimeResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation consumptionLifetime
     *
     * @param systemId 
     * @param userId 
     * @param startDate The date on which to start the time series. Defaults to the system&#39;s operational date. (optional)
     * @param endDate The last date to include in the time series. Defaults to yesterday or the last day the system reported, whichever is earlier. (optional)
     * @return RequestConfig
     */
    fun consumptionLifetimeRequestConfig(systemId: kotlin.Int, userId: kotlin.String, startDate: java.time.LocalDate?, endDate: java.time.LocalDate?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("user_id", listOf(userId.toString()))
                if (startDate != null) {
                    put("start_date", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("end_date", listOf(parseDateToQueryString(endDate)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/systems/{system_id}/consumption_lifetime".replace("{"+"system_id"+"}", encodeURIComponent(systemId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Returns consumption as measured by the consumption meter installed on the specified system. If the total duration requested is more than one month, returns one month of intervals. Intervals are 15 minutes in length and start at the top of the hour.  Requests for times that do not fall on the 15-minute marks are rounded down. For example, a request for 08:01, 08:08, 08:11, or 08:14 is treated as a request for 08:00. Intervals are listed by their end dates; therefore, the first interval returned is 15 minutes after the requested start date.  If the system doesn&#39;t have any consumption meters installed, the response includes an empty intervals array.  If you don&#39;t have permission to view consumption data, the response code is &#x60;401&#x60;.  Under some conditions, data for a given period may be temporarily unavailable.
     * @param systemId 
     * @param userId 
     * @param startAt Start of period to report on in Unix epoch time. If no start is specified, the assumed start is midnight today, in the timezone of the system. If the start is earlier than one year ago, the response includes an empty intervals list. If the start is earlier than the system&#39;s &#x60;operational_date&#x60;, the response data begins with the first interval of the &#x60;operational_date&#x60;. (optional)
     * @param endAt End of reporting period in Unix epoch time. If no end is specified, defaults to the time of the request. If the end is later than the last reported interval the response data ends with the last reported interval. (optional)
     * @return ConsumptionStatsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun consumptionStats(systemId: kotlin.Int, userId: kotlin.String, startAt: kotlin.Long? = null, endAt: kotlin.Long? = null) : ConsumptionStatsResponse {
        val localVarResponse = consumptionStatsWithHttpInfo(systemId = systemId, userId = userId, startAt = startAt, endAt = endAt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ConsumptionStatsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Returns consumption as measured by the consumption meter installed on the specified system. If the total duration requested is more than one month, returns one month of intervals. Intervals are 15 minutes in length and start at the top of the hour.  Requests for times that do not fall on the 15-minute marks are rounded down. For example, a request for 08:01, 08:08, 08:11, or 08:14 is treated as a request for 08:00. Intervals are listed by their end dates; therefore, the first interval returned is 15 minutes after the requested start date.  If the system doesn&#39;t have any consumption meters installed, the response includes an empty intervals array.  If you don&#39;t have permission to view consumption data, the response code is &#x60;401&#x60;.  Under some conditions, data for a given period may be temporarily unavailable.
     * @param systemId 
     * @param userId 
     * @param startAt Start of period to report on in Unix epoch time. If no start is specified, the assumed start is midnight today, in the timezone of the system. If the start is earlier than one year ago, the response includes an empty intervals list. If the start is earlier than the system&#39;s &#x60;operational_date&#x60;, the response data begins with the first interval of the &#x60;operational_date&#x60;. (optional)
     * @param endAt End of reporting period in Unix epoch time. If no end is specified, defaults to the time of the request. If the end is later than the last reported interval the response data ends with the last reported interval. (optional)
     * @return ApiResponse<ConsumptionStatsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun consumptionStatsWithHttpInfo(systemId: kotlin.Int, userId: kotlin.String, startAt: kotlin.Long?, endAt: kotlin.Long?) : ApiResponse<ConsumptionStatsResponse?> {
        val localVariableConfig = consumptionStatsRequestConfig(systemId = systemId, userId = userId, startAt = startAt, endAt = endAt)

        return request<Unit, ConsumptionStatsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation consumptionStats
     *
     * @param systemId 
     * @param userId 
     * @param startAt Start of period to report on in Unix epoch time. If no start is specified, the assumed start is midnight today, in the timezone of the system. If the start is earlier than one year ago, the response includes an empty intervals list. If the start is earlier than the system&#39;s &#x60;operational_date&#x60;, the response data begins with the first interval of the &#x60;operational_date&#x60;. (optional)
     * @param endAt End of reporting period in Unix epoch time. If no end is specified, defaults to the time of the request. If the end is later than the last reported interval the response data ends with the last reported interval. (optional)
     * @return RequestConfig
     */
    fun consumptionStatsRequestConfig(systemId: kotlin.Int, userId: kotlin.String, startAt: kotlin.Long?, endAt: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("user_id", listOf(userId.toString()))
                if (startAt != null) {
                    put("start_at", listOf(startAt.toString()))
                }
                if (endAt != null) {
                    put("end_at", listOf(endAt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/systems/{system_id}/consumption_stats".replace("{"+"system_id"+"}", encodeURIComponent(systemId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter production
     */
     enum class ProductionEnergyLifetime(val value: kotlin.String) {
         @Json(name = "all") all("all")
     }

    /**
     * 
     * Returns a time series of energy produced on the system over its lifetime. All measurements are in Watt-hours.  The time series includes one entry for each day from the &#x60;start_date&#x60; to the &#x60;end_date&#x60;. There are no gaps in the time series. If the response includes trailing zeroes, such as &#x60;[909, 4970, 0, 0, 0]&#x60;, then no energy has been reported for the last days in the series. You can check the system&#39;s status in the &#x60;meta&#x60; attribute of the response to determine when the system last reported and whether it has communication or production problems.  If the system has a meter, the time series includes data as measured by the microinverters until the first full day after the meter has been installed, when it switches to using the data as measured by the meter. This is called the \&quot;merged time series\&quot;. In addition, the response includes the attribute &#x60;meter_start_date&#x60;, to indicate where in the time series the meter measurements begin to be used. You can retrieve the complete time series from the meter and from the microinverters by adding the parameter &#x60;production&#x3D;all&#x60; to the request.
     * @param systemId 
     * @param userId 
     * @param startDate The date on which to start the time series. Defaults to the system&#39;s operational date. (optional)
     * @param endDate The last date to include in the time series. Defaults to yesterday or the last day the system reported, whichever is earlier. (optional)
     * @param production When &#x60;all&#x60;, returns the merged time series plus the time series as reported by the microinverters and the meter on the system. Other values are ignored. (optional)
     * @return EnergyLifetimeResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun energyLifetime(systemId: kotlin.Int, userId: kotlin.String, startDate: java.time.LocalDate? = null, endDate: java.time.LocalDate? = null, production: ProductionEnergyLifetime? = null) : EnergyLifetimeResponse {
        val localVarResponse = energyLifetimeWithHttpInfo(systemId = systemId, userId = userId, startDate = startDate, endDate = endDate, production = production)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnergyLifetimeResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Returns a time series of energy produced on the system over its lifetime. All measurements are in Watt-hours.  The time series includes one entry for each day from the &#x60;start_date&#x60; to the &#x60;end_date&#x60;. There are no gaps in the time series. If the response includes trailing zeroes, such as &#x60;[909, 4970, 0, 0, 0]&#x60;, then no energy has been reported for the last days in the series. You can check the system&#39;s status in the &#x60;meta&#x60; attribute of the response to determine when the system last reported and whether it has communication or production problems.  If the system has a meter, the time series includes data as measured by the microinverters until the first full day after the meter has been installed, when it switches to using the data as measured by the meter. This is called the \&quot;merged time series\&quot;. In addition, the response includes the attribute &#x60;meter_start_date&#x60;, to indicate where in the time series the meter measurements begin to be used. You can retrieve the complete time series from the meter and from the microinverters by adding the parameter &#x60;production&#x3D;all&#x60; to the request.
     * @param systemId 
     * @param userId 
     * @param startDate The date on which to start the time series. Defaults to the system&#39;s operational date. (optional)
     * @param endDate The last date to include in the time series. Defaults to yesterday or the last day the system reported, whichever is earlier. (optional)
     * @param production When &#x60;all&#x60;, returns the merged time series plus the time series as reported by the microinverters and the meter on the system. Other values are ignored. (optional)
     * @return ApiResponse<EnergyLifetimeResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun energyLifetimeWithHttpInfo(systemId: kotlin.Int, userId: kotlin.String, startDate: java.time.LocalDate?, endDate: java.time.LocalDate?, production: ProductionEnergyLifetime?) : ApiResponse<EnergyLifetimeResponse?> {
        val localVariableConfig = energyLifetimeRequestConfig(systemId = systemId, userId = userId, startDate = startDate, endDate = endDate, production = production)

        return request<Unit, EnergyLifetimeResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation energyLifetime
     *
     * @param systemId 
     * @param userId 
     * @param startDate The date on which to start the time series. Defaults to the system&#39;s operational date. (optional)
     * @param endDate The last date to include in the time series. Defaults to yesterday or the last day the system reported, whichever is earlier. (optional)
     * @param production When &#x60;all&#x60;, returns the merged time series plus the time series as reported by the microinverters and the meter on the system. Other values are ignored. (optional)
     * @return RequestConfig
     */
    fun energyLifetimeRequestConfig(systemId: kotlin.Int, userId: kotlin.String, startDate: java.time.LocalDate?, endDate: java.time.LocalDate?, production: ProductionEnergyLifetime?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("user_id", listOf(userId.toString()))
                if (startDate != null) {
                    put("start_date", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("end_date", listOf(parseDateToQueryString(endDate)))
                }
                if (production != null) {
                    put("production", listOf(production.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/systems/{system_id}/energy_lifetime".replace("{"+"system_id"+"}", encodeURIComponent(systemId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Returns a listing of all active Envoys currently deployed on the system.
     * @param systemId 
     * @param userId 
     * @return EnvoysResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun envoys(systemId: kotlin.Int, userId: kotlin.String) : EnvoysResponse {
        val localVarResponse = envoysWithHttpInfo(systemId = systemId, userId = userId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnvoysResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Returns a listing of all active Envoys currently deployed on the system.
     * @param systemId 
     * @param userId 
     * @return ApiResponse<EnvoysResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun envoysWithHttpInfo(systemId: kotlin.Int, userId: kotlin.String) : ApiResponse<EnvoysResponse?> {
        val localVariableConfig = envoysRequestConfig(systemId = systemId, userId = userId)

        return request<Unit, EnvoysResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation envoys
     *
     * @param systemId 
     * @param userId 
     * @return RequestConfig
     */
    fun envoysRequestConfig(systemId: kotlin.Int, userId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("user_id", listOf(userId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/systems/{system_id}/envoys".replace("{"+"system_id"+"}", encodeURIComponent(systemId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Returns a listing of active devices on the given system. A device is considered active if it has not been retired in Enlighten. \&quot;Active\&quot; does not imply that the device is currently reporting, producing, or measuring energy.
     * @param systemId 
     * @param userId 
     * @return InventoryResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun inventory(systemId: kotlin.Int, userId: kotlin.String) : InventoryResponse {
        val localVarResponse = inventoryWithHttpInfo(systemId = systemId, userId = userId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InventoryResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Returns a listing of active devices on the given system. A device is considered active if it has not been retired in Enlighten. \&quot;Active\&quot; does not imply that the device is currently reporting, producing, or measuring energy.
     * @param systemId 
     * @param userId 
     * @return ApiResponse<InventoryResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun inventoryWithHttpInfo(systemId: kotlin.Int, userId: kotlin.String) : ApiResponse<InventoryResponse?> {
        val localVariableConfig = inventoryRequestConfig(systemId = systemId, userId = userId)

        return request<Unit, InventoryResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation inventory
     *
     * @param systemId 
     * @param userId 
     * @return RequestConfig
     */
    fun inventoryRequestConfig(systemId: kotlin.Int, userId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("user_id", listOf(userId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/systems/{system_id}/inventory".replace("{"+"system_id"+"}", encodeURIComponent(systemId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Returns the summary along with the energy produced on the system over its lifetime.
     * @param userId 
     * @param siteId The identifier of the system.
     * @return kotlin.collections.List<InvertersSummaryByEnvoyOrSiteResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun invertersSummaryByEnvoyOrSite(userId: kotlin.String, siteId: kotlin.Int) : kotlin.collections.List<InvertersSummaryByEnvoyOrSiteResponse> {
        val localVarResponse = invertersSummaryByEnvoyOrSiteWithHttpInfo(userId = userId, siteId = siteId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<InvertersSummaryByEnvoyOrSiteResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Returns the summary along with the energy produced on the system over its lifetime.
     * @param userId 
     * @param siteId The identifier of the system.
     * @return ApiResponse<kotlin.collections.List<InvertersSummaryByEnvoyOrSiteResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun invertersSummaryByEnvoyOrSiteWithHttpInfo(userId: kotlin.String, siteId: kotlin.Int) : ApiResponse<kotlin.collections.List<InvertersSummaryByEnvoyOrSiteResponse>?> {
        val localVariableConfig = invertersSummaryByEnvoyOrSiteRequestConfig(userId = userId, siteId = siteId)

        return request<Unit, kotlin.collections.List<InvertersSummaryByEnvoyOrSiteResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation invertersSummaryByEnvoyOrSite
     *
     * @param userId 
     * @param siteId The identifier of the system.
     * @return RequestConfig
     */
    fun invertersSummaryByEnvoyOrSiteRequestConfig(userId: kotlin.String, siteId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("user_id", listOf(userId.toString()))
                put("site_id", listOf(siteId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/systems/inverters_summary_by_envoy_or_site",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This endpoint is deprecated and will be removed in a future release. Use &#x60;production_meter_readings&#x60; or &#x60;energy_lifetime&#x60; instead.  Returns the energy production of the system for the month starting on the given date. The start date must be at least one month ago. If a meter or meters are installed on the system, measurements come from the meter; otherwise, measurements come from the microinverters.  This endpoint can return a response of Data Temporarily Unavailable.
     * @param systemId 
     * @param userId 
     * @param startDate Start date for reporting period. The reporting period ends on the previous day of the next month; for example, a &#x60;start_date&#x60; of 2011-07-20 returns data through 2011-06-19. When the start date is the first of a calendar month, the end date is the last day of that month.
     * @return MonthlyProductionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun monthlyProduction(systemId: kotlin.Int, userId: kotlin.String, startDate: java.time.LocalDate) : MonthlyProductionResponse {
        @Suppress("DEPRECATION")
        val localVarResponse = monthlyProductionWithHttpInfo(systemId = systemId, userId = userId, startDate = startDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MonthlyProductionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This endpoint is deprecated and will be removed in a future release. Use &#x60;production_meter_readings&#x60; or &#x60;energy_lifetime&#x60; instead.  Returns the energy production of the system for the month starting on the given date. The start date must be at least one month ago. If a meter or meters are installed on the system, measurements come from the meter; otherwise, measurements come from the microinverters.  This endpoint can return a response of Data Temporarily Unavailable.
     * @param systemId 
     * @param userId 
     * @param startDate Start date for reporting period. The reporting period ends on the previous day of the next month; for example, a &#x60;start_date&#x60; of 2011-07-20 returns data through 2011-06-19. When the start date is the first of a calendar month, the end date is the last day of that month.
     * @return ApiResponse<MonthlyProductionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun monthlyProductionWithHttpInfo(systemId: kotlin.Int, userId: kotlin.String, startDate: java.time.LocalDate) : ApiResponse<MonthlyProductionResponse?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = monthlyProductionRequestConfig(systemId = systemId, userId = userId, startDate = startDate)

        return request<Unit, MonthlyProductionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation monthlyProduction
     *
     * @param systemId 
     * @param userId 
     * @param startDate Start date for reporting period. The reporting period ends on the previous day of the next month; for example, a &#x60;start_date&#x60; of 2011-07-20 returns data through 2011-06-19. When the start date is the first of a calendar month, the end date is the last day of that month.
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun monthlyProductionRequestConfig(systemId: kotlin.Int, userId: kotlin.String, startDate: java.time.LocalDate) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("user_id", listOf(userId.toString()))
                put("start_date", listOf(parseDateToQueryString(startDate)))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/systems/{system_id}/monthly_production".replace("{"+"system_id"+"}", encodeURIComponent(systemId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Returns the last known \&quot;odometer\&quot; reading of each revenue-grade production meter on the system as of the requested time.  This endpoint includes entries for every production meter on the requested system, regardless of whether the meter is currently in service or retired. &#x60;read_at&#x60; is the time at which the reading was taken, and is always less than or equal to the requested &#x60;end_at&#x60;. Commonly, the reading will be within 30 minutes of the requested &#x60;end_at&#x60;; however, larger deltas can occur and do not necessarily mean there is a problem with the meter or the system it is on. Systems that are configured to report infrequently can show large deltas on all meters, especially when &#x60;end_at&#x60; is close to the current time. Meters that have been retired from a system will show an &#x60;end_at&#x60; that doesn&#39;t change, and that eventually is far away from the current time.
     * @param systemId 
     * @param userId 
     * @param endAt  (optional)
     * @return ProductionMeterReadingsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productionMeterReadings(systemId: kotlin.Int, userId: kotlin.String, endAt: kotlin.Long? = null) : ProductionMeterReadingsResponse {
        val localVarResponse = productionMeterReadingsWithHttpInfo(systemId = systemId, userId = userId, endAt = endAt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductionMeterReadingsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Returns the last known \&quot;odometer\&quot; reading of each revenue-grade production meter on the system as of the requested time.  This endpoint includes entries for every production meter on the requested system, regardless of whether the meter is currently in service or retired. &#x60;read_at&#x60; is the time at which the reading was taken, and is always less than or equal to the requested &#x60;end_at&#x60;. Commonly, the reading will be within 30 minutes of the requested &#x60;end_at&#x60;; however, larger deltas can occur and do not necessarily mean there is a problem with the meter or the system it is on. Systems that are configured to report infrequently can show large deltas on all meters, especially when &#x60;end_at&#x60; is close to the current time. Meters that have been retired from a system will show an &#x60;end_at&#x60; that doesn&#39;t change, and that eventually is far away from the current time.
     * @param systemId 
     * @param userId 
     * @param endAt  (optional)
     * @return ApiResponse<ProductionMeterReadingsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productionMeterReadingsWithHttpInfo(systemId: kotlin.Int, userId: kotlin.String, endAt: kotlin.Long?) : ApiResponse<ProductionMeterReadingsResponse?> {
        val localVariableConfig = productionMeterReadingsRequestConfig(systemId = systemId, userId = userId, endAt = endAt)

        return request<Unit, ProductionMeterReadingsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productionMeterReadings
     *
     * @param systemId 
     * @param userId 
     * @param endAt  (optional)
     * @return RequestConfig
     */
    fun productionMeterReadingsRequestConfig(systemId: kotlin.Int, userId: kotlin.String, endAt: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("user_id", listOf(userId.toString()))
                if (endAt != null) {
                    put("end_at", listOf(endAt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/systems/{system_id}/production_meter_readings".replace("{"+"system_id"+"}", encodeURIComponent(systemId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Returns performance statistics as measured by the revenue-grade meters installed on the specified system. If the total duration requested is more than one month, returns one month of intervals. Intervals are 15 minutes in length and start at the top of the hour.  Requests for times that do not fall on the 15-minute marks are rounded down. For example, a request for 08:01, 08:08, 08:11, or 08:14 is treated as a request for 08:00. Intervals are listed by their end dates; therefore, the first interval returned is 15 minutes after the requested start date.  If the system doesn&#39;t have any revenue-grade meters installed, the response includes an empty intervals array.  Under some conditions, data for a given period may be temporarily unavailable.
     * @param systemId 
     * @param userId 
     * @param startAt Start of period to report on in Unix epoch time. If no start is specified, the assumed start is midnight today, in the timezone of the system. If the start is earlier than one year ago, the response includes an empty intervals list. If the start is earlier than the system&#39;s &#x60;operational_date&#x60;, the response data begins with the first interval of the &#x60;operational_date&#x60;. (optional)
     * @param endAt End of reporting period in Unix epoch time. If no end is specified, defaults to the time of the request. If the end is later than the last reported interval the response data ends with the last reported interval. (optional)
     * @return RgmStatsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun rgmStats(systemId: kotlin.Int, userId: kotlin.String, startAt: kotlin.Long? = null, endAt: kotlin.Long? = null) : RgmStatsResponse {
        val localVarResponse = rgmStatsWithHttpInfo(systemId = systemId, userId = userId, startAt = startAt, endAt = endAt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RgmStatsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Returns performance statistics as measured by the revenue-grade meters installed on the specified system. If the total duration requested is more than one month, returns one month of intervals. Intervals are 15 minutes in length and start at the top of the hour.  Requests for times that do not fall on the 15-minute marks are rounded down. For example, a request for 08:01, 08:08, 08:11, or 08:14 is treated as a request for 08:00. Intervals are listed by their end dates; therefore, the first interval returned is 15 minutes after the requested start date.  If the system doesn&#39;t have any revenue-grade meters installed, the response includes an empty intervals array.  Under some conditions, data for a given period may be temporarily unavailable.
     * @param systemId 
     * @param userId 
     * @param startAt Start of period to report on in Unix epoch time. If no start is specified, the assumed start is midnight today, in the timezone of the system. If the start is earlier than one year ago, the response includes an empty intervals list. If the start is earlier than the system&#39;s &#x60;operational_date&#x60;, the response data begins with the first interval of the &#x60;operational_date&#x60;. (optional)
     * @param endAt End of reporting period in Unix epoch time. If no end is specified, defaults to the time of the request. If the end is later than the last reported interval the response data ends with the last reported interval. (optional)
     * @return ApiResponse<RgmStatsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun rgmStatsWithHttpInfo(systemId: kotlin.Int, userId: kotlin.String, startAt: kotlin.Long?, endAt: kotlin.Long?) : ApiResponse<RgmStatsResponse?> {
        val localVariableConfig = rgmStatsRequestConfig(systemId = systemId, userId = userId, startAt = startAt, endAt = endAt)

        return request<Unit, RgmStatsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rgmStats
     *
     * @param systemId 
     * @param userId 
     * @param startAt Start of period to report on in Unix epoch time. If no start is specified, the assumed start is midnight today, in the timezone of the system. If the start is earlier than one year ago, the response includes an empty intervals list. If the start is earlier than the system&#39;s &#x60;operational_date&#x60;, the response data begins with the first interval of the &#x60;operational_date&#x60;. (optional)
     * @param endAt End of reporting period in Unix epoch time. If no end is specified, defaults to the time of the request. If the end is later than the last reported interval the response data ends with the last reported interval. (optional)
     * @return RequestConfig
     */
    fun rgmStatsRequestConfig(systemId: kotlin.Int, userId: kotlin.String, startAt: kotlin.Long?, endAt: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("user_id", listOf(userId.toString()))
                if (startAt != null) {
                    put("start_at", listOf(startAt.toString()))
                }
                if (endAt != null) {
                    put("end_at", listOf(endAt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/systems/{system_id}/rgm_stats".replace("{"+"system_id"+"}", encodeURIComponent(systemId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Get system ID by envoy serial number.
     * @param userId 
     * @param serialNum Serial number of the envoy.
     * @return SearchSystemIdResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchSystemId(userId: kotlin.String, serialNum: kotlin.String) : SearchSystemIdResponse {
        val localVarResponse = searchSystemIdWithHttpInfo(userId = userId, serialNum = serialNum)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SearchSystemIdResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Get system ID by envoy serial number.
     * @param userId 
     * @param serialNum Serial number of the envoy.
     * @return ApiResponse<SearchSystemIdResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchSystemIdWithHttpInfo(userId: kotlin.String, serialNum: kotlin.String) : ApiResponse<SearchSystemIdResponse?> {
        val localVariableConfig = searchSystemIdRequestConfig(userId = userId, serialNum = serialNum)

        return request<Unit, SearchSystemIdResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchSystemId
     *
     * @param userId 
     * @param serialNum Serial number of the envoy.
     * @return RequestConfig
     */
    fun searchSystemIdRequestConfig(userId: kotlin.String, serialNum: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("user_id", listOf(userId.toString()))
                put("serial_num", listOf(serialNum.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/systems/search_system_id",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Returns performance statistics for the specified system as reported by microinverters installed on the system. If the total duration requested is more than one day, returns one day of intervals. Intervals are 5 minutes in length and start at the top of the hour.  Requests for times that do not fall on the 5-minute marks are rounded down. For example, a request for 08:01, 08:02, 08:03, or 08:04 is treated as a request for 08:00. Intervals are listed by their end dates; therefore, the first interval returned is 5 minutes after the requested start date.  The response includes intervals that have been reported for the requested period. Gaps in reporting are not filled with 0-value intervals. The dark hours on a system are an example of such a gap, because the microinverters do not produce at night.  Sometimes a request cannot be processed because the requested dates are invalid for the system in question. Examples include asking for stats starting at a time that is later than the system&#39;s last reported interval, or asking for stats before a system has started production. In cases such as these, the response code is &#x60;422&#x60; and the response body includes an error reason as well as the parameters used to process the request.  If the system doesn&#39;t have any microinverters installed, the response includes an empty intervals array. Under some conditions, data for a given period may be temporarily unavailable.
     * @param systemId 
     * @param userId 
     * @param startAt Start of reporting period in Unix epoch time. If no start is specified, defaults to midnight today, in the timezone of the system. If the start date is earlier than one year ago today, the response includes an empty intervals list. If the start is earlier than the system&#39;s &#x60;operational_date&#x60;, the response data begins with the &#x60;operational_date&#x60;. (optional)
     * @param endAt End of reporting period in Unix epoch time. If no end is specified, the assumed end is now. If the end is later than the last reporting interval the response data ends with the last reported interval. (optional)
     * @return StatsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stats(systemId: kotlin.Int, userId: kotlin.String, startAt: kotlin.Long? = null, endAt: kotlin.Long? = null) : StatsResponse {
        val localVarResponse = statsWithHttpInfo(systemId = systemId, userId = userId, startAt = startAt, endAt = endAt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StatsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Returns performance statistics for the specified system as reported by microinverters installed on the system. If the total duration requested is more than one day, returns one day of intervals. Intervals are 5 minutes in length and start at the top of the hour.  Requests for times that do not fall on the 5-minute marks are rounded down. For example, a request for 08:01, 08:02, 08:03, or 08:04 is treated as a request for 08:00. Intervals are listed by their end dates; therefore, the first interval returned is 5 minutes after the requested start date.  The response includes intervals that have been reported for the requested period. Gaps in reporting are not filled with 0-value intervals. The dark hours on a system are an example of such a gap, because the microinverters do not produce at night.  Sometimes a request cannot be processed because the requested dates are invalid for the system in question. Examples include asking for stats starting at a time that is later than the system&#39;s last reported interval, or asking for stats before a system has started production. In cases such as these, the response code is &#x60;422&#x60; and the response body includes an error reason as well as the parameters used to process the request.  If the system doesn&#39;t have any microinverters installed, the response includes an empty intervals array. Under some conditions, data for a given period may be temporarily unavailable.
     * @param systemId 
     * @param userId 
     * @param startAt Start of reporting period in Unix epoch time. If no start is specified, defaults to midnight today, in the timezone of the system. If the start date is earlier than one year ago today, the response includes an empty intervals list. If the start is earlier than the system&#39;s &#x60;operational_date&#x60;, the response data begins with the &#x60;operational_date&#x60;. (optional)
     * @param endAt End of reporting period in Unix epoch time. If no end is specified, the assumed end is now. If the end is later than the last reporting interval the response data ends with the last reported interval. (optional)
     * @return ApiResponse<StatsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun statsWithHttpInfo(systemId: kotlin.Int, userId: kotlin.String, startAt: kotlin.Long?, endAt: kotlin.Long?) : ApiResponse<StatsResponse?> {
        val localVariableConfig = statsRequestConfig(systemId = systemId, userId = userId, startAt = startAt, endAt = endAt)

        return request<Unit, StatsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stats
     *
     * @param systemId 
     * @param userId 
     * @param startAt Start of reporting period in Unix epoch time. If no start is specified, defaults to midnight today, in the timezone of the system. If the start date is earlier than one year ago today, the response includes an empty intervals list. If the start is earlier than the system&#39;s &#x60;operational_date&#x60;, the response data begins with the &#x60;operational_date&#x60;. (optional)
     * @param endAt End of reporting period in Unix epoch time. If no end is specified, the assumed end is now. If the end is later than the last reporting interval the response data ends with the last reported interval. (optional)
     * @return RequestConfig
     */
    fun statsRequestConfig(systemId: kotlin.Int, userId: kotlin.String, startAt: kotlin.Long?, endAt: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("user_id", listOf(userId.toString()))
                if (startAt != null) {
                    put("start_at", listOf(startAt.toString()))
                }
                if (endAt != null) {
                    put("end_at", listOf(endAt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/systems/{system_id}/stats".replace("{"+"system_id"+"}", encodeURIComponent(systemId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Returns summary information for the specified system.
     * @param systemId 
     * @param userId 
     * @param summaryDate Start of reporting period. If no &#x60;summary_date&#x60; is provided, the start is the current day at midnight site-local time. Otherwise, the start is midnight site-local time of the requested day. If the requested date cannot be parsed or is in the future, the response includes an informative error message and &#x60;422&#x60; status. (optional)
     * @return SummaryResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun summary(systemId: kotlin.Int, userId: kotlin.String, summaryDate: java.time.LocalDate? = null) : SummaryResponse {
        val localVarResponse = summaryWithHttpInfo(systemId = systemId, userId = userId, summaryDate = summaryDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SummaryResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Returns summary information for the specified system.
     * @param systemId 
     * @param userId 
     * @param summaryDate Start of reporting period. If no &#x60;summary_date&#x60; is provided, the start is the current day at midnight site-local time. Otherwise, the start is midnight site-local time of the requested day. If the requested date cannot be parsed or is in the future, the response includes an informative error message and &#x60;422&#x60; status. (optional)
     * @return ApiResponse<SummaryResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun summaryWithHttpInfo(systemId: kotlin.Int, userId: kotlin.String, summaryDate: java.time.LocalDate?) : ApiResponse<SummaryResponse?> {
        val localVariableConfig = summaryRequestConfig(systemId = systemId, userId = userId, summaryDate = summaryDate)

        return request<Unit, SummaryResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation summary
     *
     * @param systemId 
     * @param userId 
     * @param summaryDate Start of reporting period. If no &#x60;summary_date&#x60; is provided, the start is the current day at midnight site-local time. Otherwise, the start is midnight site-local time of the requested day. If the requested date cannot be parsed or is in the future, the response includes an informative error message and &#x60;422&#x60; status. (optional)
     * @return RequestConfig
     */
    fun summaryRequestConfig(systemId: kotlin.Int, userId: kotlin.String, summaryDate: java.time.LocalDate?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("user_id", listOf(userId.toString()))
                if (summaryDate != null) {
                    put("summary_date", listOf(parseDateToQueryString(summaryDate)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/systems/{system_id}/summary".replace("{"+"system_id"+"}", encodeURIComponent(systemId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Returns a list of systems for which the user can make API requests. There is a limit to the number of systems that can be returned at one time. If the first request does not return a full list, use the &#x60;next&#x60; attribute in the response body to request the next page of systems. By default, systems are returned in batches of 100. The maximum page size is 1000.
     * @param userId 
     * @param next  (optional)
     * @param limit  (optional, default to 100)
     * @param systemId  (optional)
     * @param systemId2  (optional)
     * @param systemName  (optional)
     * @param systemName2  (optional)
     * @param status  (optional)
     * @param status2  (optional)
     * @param reference  (optional)
     * @param reference2  (optional)
     * @param installer  (optional)
     * @param installer2  (optional)
     * @param connectionType  (optional)
     * @param connectionType2  (optional)
     * @return SystemsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun systems(userId: kotlin.String, next: kotlin.String? = null, limit: kotlin.Int? = 100, systemId: kotlin.Int? = null, systemId2: kotlin.collections.List<kotlin.Int>? = null, systemName: kotlin.String? = null, systemName2: kotlin.collections.List<kotlin.String>? = null, status: Status? = null, status2: kotlin.collections.List<Status>? = null, reference: kotlin.String? = null, reference2: kotlin.collections.List<kotlin.String>? = null, installer: kotlin.String? = null, installer2: kotlin.collections.List<kotlin.String>? = null, connectionType: ConnectionType? = null, connectionType2: kotlin.collections.List<ConnectionType>? = null) : SystemsResponse {
        val localVarResponse = systemsWithHttpInfo(userId = userId, next = next, limit = limit, systemId = systemId, systemId2 = systemId2, systemName = systemName, systemName2 = systemName2, status = status, status2 = status2, reference = reference, reference2 = reference2, installer = installer, installer2 = installer2, connectionType = connectionType, connectionType2 = connectionType2)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SystemsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Returns a list of systems for which the user can make API requests. There is a limit to the number of systems that can be returned at one time. If the first request does not return a full list, use the &#x60;next&#x60; attribute in the response body to request the next page of systems. By default, systems are returned in batches of 100. The maximum page size is 1000.
     * @param userId 
     * @param next  (optional)
     * @param limit  (optional, default to 100)
     * @param systemId  (optional)
     * @param systemId2  (optional)
     * @param systemName  (optional)
     * @param systemName2  (optional)
     * @param status  (optional)
     * @param status2  (optional)
     * @param reference  (optional)
     * @param reference2  (optional)
     * @param installer  (optional)
     * @param installer2  (optional)
     * @param connectionType  (optional)
     * @param connectionType2  (optional)
     * @return ApiResponse<SystemsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun systemsWithHttpInfo(userId: kotlin.String, next: kotlin.String?, limit: kotlin.Int?, systemId: kotlin.Int?, systemId2: kotlin.collections.List<kotlin.Int>?, systemName: kotlin.String?, systemName2: kotlin.collections.List<kotlin.String>?, status: Status?, status2: kotlin.collections.List<Status>?, reference: kotlin.String?, reference2: kotlin.collections.List<kotlin.String>?, installer: kotlin.String?, installer2: kotlin.collections.List<kotlin.String>?, connectionType: ConnectionType?, connectionType2: kotlin.collections.List<ConnectionType>?) : ApiResponse<SystemsResponse?> {
        val localVariableConfig = systemsRequestConfig(userId = userId, next = next, limit = limit, systemId = systemId, systemId2 = systemId2, systemName = systemName, systemName2 = systemName2, status = status, status2 = status2, reference = reference, reference2 = reference2, installer = installer, installer2 = installer2, connectionType = connectionType, connectionType2 = connectionType2)

        return request<Unit, SystemsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation systems
     *
     * @param userId 
     * @param next  (optional)
     * @param limit  (optional, default to 100)
     * @param systemId  (optional)
     * @param systemId2  (optional)
     * @param systemName  (optional)
     * @param systemName2  (optional)
     * @param status  (optional)
     * @param status2  (optional)
     * @param reference  (optional)
     * @param reference2  (optional)
     * @param installer  (optional)
     * @param installer2  (optional)
     * @param connectionType  (optional)
     * @param connectionType2  (optional)
     * @return RequestConfig
     */
    fun systemsRequestConfig(userId: kotlin.String, next: kotlin.String?, limit: kotlin.Int?, systemId: kotlin.Int?, systemId2: kotlin.collections.List<kotlin.Int>?, systemName: kotlin.String?, systemName2: kotlin.collections.List<kotlin.String>?, status: Status?, status2: kotlin.collections.List<Status>?, reference: kotlin.String?, reference2: kotlin.collections.List<kotlin.String>?, installer: kotlin.String?, installer2: kotlin.collections.List<kotlin.String>?, connectionType: ConnectionType?, connectionType2: kotlin.collections.List<ConnectionType>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("user_id", listOf(userId.toString()))
                if (next != null) {
                    put("next", listOf(next.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (systemId != null) {
                    put("system_id", listOf(systemId.toString()))
                }
                if (systemId2 != null) {
                    put("system_id[]", toMultiValue(systemId2.toList(), "multi"))
                }
                if (systemName != null) {
                    put("system_name", listOf(systemName.toString()))
                }
                if (systemName2 != null) {
                    put("system_name[]", toMultiValue(systemName2.toList(), "multi"))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (status2 != null) {
                    put("status[]", toMultiValue(status2.toList(), "multi"))
                }
                if (reference != null) {
                    put("reference", listOf(reference.toString()))
                }
                if (reference2 != null) {
                    put("reference[]", toMultiValue(reference2.toList(), "multi"))
                }
                if (installer != null) {
                    put("installer", listOf(installer.toString()))
                }
                if (installer2 != null) {
                    put("installer[]", toMultiValue(installer2.toList(), "multi"))
                }
                if (connectionType != null) {
                    put("connection_type", listOf(connectionType.toString()))
                }
                if (connectionType2 != null) {
                    put("connection_type[]", toMultiValue(connectionType2.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/systems",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
